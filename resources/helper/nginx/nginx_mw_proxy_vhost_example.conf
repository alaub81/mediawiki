# Global NGINX configuration for MediaWiki with imgproxy and GoAccess logging

# --- Define custom log format for GoAccess ---
log_format goaccess_logging
    '$server_name $remote_addr - $remote_user '
    '[$time_local] "$request" $status $body_bytes_sent '
    '"$http_referer" "$http_user_agent" '
    '$upstream_cache_status '
    '"$sent_http_content_type" '
    '$ssl_protocol $ssl_cipher';

# --- Upstream definitions ---
upstream mediawiki_prod {
    server 127.0.0.1:8093;
}
upstream imgproxy_backend {
    server 127.0.0.1:8989;
}
upstream goaccess_backend {
    server 127.0.0.1:7890;
}

# --- Expires map based on Content-Type ---
map $sent_http_content_type $expires {
    default                    off;
    text/css                   max;
    text/javascript            max;
    application/javascript     max;
    ~image/                    max;
    application/pdf		         max;
    "text/css; charset=utf-8"  max;
    "text/javascript; charset=utf-8" max;
}

# --- Image format selection based on Accept header ---
map $http_accept $imgfmt {
    ~avif  avif;
    ~webp  webp;
    default png;
}

# --- manual cache bypass via ?nocache=... ---
map $arg_nocache $bypass_cache { default 0; "" 0; ~. 1; }

# --- MediaWiki HTML cache (anonymous) ---
proxy_cache_path /var/cache/nginx/mw levels=1:2 keys_zone=mwcache:100m inactive=60m max_size=2g;

# --- Static/media cache (images/CSS/JS via proxy) ---
proxy_cache_path /var/cache/nginx/img levels=1:2 keys_zone=img_cache:100m inactive=60d max_size=5g;

# --- Bypass rules for logged-in users / unsafe methods/actions ---
map $http_cookie $mw_cache_bypass {
    default 0;
    "~*(session|UserID|Token|LoggedIn)=" 1;  # logged-in or edit token
}
map $request_method $mw_bypass_method { default 0; POST 1; }
map $arg_action     $mw_bypass_action { default 0; "~^(edit|submit|history|raw|watch|delete|purge)$" 1; }

# Optional: manual nocache switch (?nocache=1)
map $arg_nocache $mw_bypass_nocache { default 0; "1" 1; }

# Optional: split cache for MobileFrontend toggle (desktop vs. mobile)
map $http_cookie $mf_useformat { default ""; "~*mf_useformat=([^;]+)" $1; }

# --- Server blocks ---
# Redirect all HTTP to HTTPS on canonical host
server {
    listen 80;
    listen [::]:80;
    server_name example.com www.example.com;

    # Redirect root to the wiki homepage
    location = / {
      return 301 https://www.example.com/wiki/Startseite;
    }

    # Redirect everything else to HTTPS on the canonical host
    return 301 https://www.example.com$request_uri;
}

# Redirect apex to www
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
    server_name example.com;

    # Use a SAN certificate that actually includes ALL the above names
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/example.com/chain.pem;

    include /etc/nginx/conf.d/includes/ssl.conf;

    # Always move to apex (canonical host)
    return 301 https://www.example.com$request_uri;
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
    server_name www.example.com;
    location = / {
        return 301 https://www.example.com/wiki/Startseite;
    }

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/example.com/chain.pem;
    # SSL/TLS protocols
    ssl_protocols TLSv1.3 TLSv1.2;
    # Cipher Suites
    ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';
    ssl_prefer_server_ciphers on;
    # ECDH Curve
    ssl_ecdh_curve X25519:secp256r1;
    # Sessions
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    access_log /var/log/nginx/access_all.log goaccess_logging;

    # charset
    charset utf-8;
    override_charset on;

    # enable compression
    gzip on;
    gzip_disable "msie6";
    gzip_vary on;
    gzip_proxied off;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_min_length 256;
    gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript application/vnd.ms-fontobject application/x-font-ttf font/opentype image/svg+xml image/x-icon image/vnd.microsoft.icon;

    # Let's Encrypt ACME challenge location
    location ^~ /.well-known/acme-challenge/ {
        root /srv/certbot/www;
        default_type "text/plain";
        add_header Cache-Control "no-store";
        try_files $uri =404;
        auth_basic off;
        allow all;
    }

    add_header X-Cache $upstream_cache_status always;
    expires $expires;

    # Maximum upload size (adjust as configured in MediaWiki)
    client_max_body_size 110m;

    location / {
        # Proxy basics
        proxy_set_header Host              $host;
        proxy_set_header X-Forwarded-For   $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_pass http://mediawiki_prod;

        # Cache settings (honor upstream Cache-Control from MediaWiki)
        proxy_cache           mwcache;
        proxy_cache_key       "$scheme$host$request_uri|mf=$mf_useformat";

        # Bypass/Don't-store conditions
        proxy_cache_bypass  $mw_cache_bypass $mw_bypass_method $mw_bypass_action $mw_bypass_nocache;
        proxy_no_cache      $mw_cache_bypass $mw_bypass_method $mw_bypass_action $mw_bypass_nocache;

        # Serve stale on errors / while updating (nice for spikes/deploys)
        proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;
        proxy_cache_background_update on;
    }

    # --- Never cache the API ---
    location ~* ^/(w/)?api\.php$ {
        proxy_set_header Host              $host;
        proxy_set_header X-Forwarded-For   $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_pass http://mediawiki_prod;
        proxy_no_cache 1;
        proxy_cache_bypass 1;
    }

    # --- Do not cache Special: pages (dynamic) ---
    location ~ ^/wiki/(Special|Spezial): {
        proxy_set_header Host              $host;
        proxy_set_header X-Forwarded-For   $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_pass http://mediawiki_prod;
        proxy_no_cache 1;
        proxy_cache_bypass 1;
    }

    location ~* ^/images/.*\.svg$ {
        proxy_pass http://mediawiki_prod;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering on;
        proxy_buffer_size 16k;
        proxy_buffers 8 32k;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";

        include /etc/nginx/conf.d/includes/security-headers.conf;
        include /etc/nginx/conf.d/includes/csp.conf;
    }

    location ~* ^/images/(?:thumb/)?(.+\.(?:jpe?g|png|gif|webp|avif))$ {
        # direct to MediaWiki
        set $src "http://127.0.0.1:8093$uri$is_args$args";

        # Pass on header
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout 300ms;
        proxy_send_timeout    1s;
        proxy_read_timeout    1s;

        proxy_cache         img_cache;
        proxy_cache_bypass  $mw_cache_bypass $mw_bypass_method $mw_bypass_action $mw_bypass_nocache;
        proxy_no_cache      $mw_cache_bypass $mw_bypass_method $mw_bypass_action $mw_bypass_nocache;

        proxy_cache_key    "$scheme$proxy_host$request_uri|$imgfmt";
        proxy_cache_lock    on;
        proxy_cache_valid   200 301 302 30d;
        proxy_cache_use_stale error timeout invalid_header http_500 http_502 http_503 http_504 updating;

        proxy_hide_header Vary;
        add_header Vary Accept always;

        # Enable fallback
        proxy_intercept_errors on;
        error_page 500 502 503 504 408 = @wiki_direct;
        # Optionally, also switch to imgproxy for 404 errors:
        # error_page 404 = @wiki_direct;

        proxy_pass http://imgproxy_backend/insecure/plain/$src@$imgfmt;

        # Buffer
        proxy_buffering on;
        proxy_buffer_size 16k;
        proxy_buffers 8 32k;

        # Browser-Caching
        expires off;
        proxy_hide_header Cache-Control;
        add_header Cache-Control "public, max-age=2592000, immutable";
        include /etc/nginx/conf.d/includes/security-headers.conf;
        include /etc/nginx/conf.d/includes/csp.conf;
    }

    # --- Fallback: directly from MediaWiki without re-encoding ---
    location @wiki_direct {
        add_header X-Imgproxy-Fallback "1" always;

        proxy_pass http://mediawiki_prod;   # Query & URI werden automatisch mitgenommen
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_cache off;  # optional: Fallback nicht im Proxy cachen

        expires 7d;
        add_header Cache-Control "public, max-age=604800";
        add_header Vary Accept always;
        include /etc/nginx/conf.d/includes/security-headers.conf;
        include /etc/nginx/conf.d/includes/csp.conf;
    }

}
